name: Issue Quality Gate

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  issues: write

jobs:
  issue_quality_gate:
    name: Issue quality check
    runs-on: ubuntu-latest

    steps:
      - name: Validate issue content
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue = context.payload.issue;

            const labels = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name));
            const isBug = labels.includes('bug');
            const isFeature = labels.includes('enhancement');

            // Only enforce for bug + feature issues created via your templates
            if (!isBug && !isFeature) return;

            const body = (issue.body || '').trim();

            // Issue Forms render headings like "### Steps to reproduce"
            function extractSection(heading) {
              const re = new RegExp(`^###\\s+${heading}\\s*$([\\s\\S]*?)(?=\\n###\\s+|$)`, 'mi');
              const match = body.match(re);
              return match ? (match[1] || '').trim() : '';
            }

            const placeholderPhrases = new Set([
              'n/a','na','none','nothing','no','tbd','todo','unknown','-','--','idk',"i don't know",'i dont know',
              'same as above','asdf','test'
            ]);

            function normalize(text) {
              return (text || '')
                .replace(/<!--[\s\S]*?-->/g, '') // strip HTML comments
                .replace(/\r/g, '')
                .trim();
            }

            function cleaned(text) {
              return normalize(text).replace(/\s+/g, ' ').trim();
            }

            function looksLikePlaceholder(text) {
              const c = cleaned(text).toLowerCase();
              if (!c) return true;
              if (placeholderPhrases.has(c)) return true;
              return false;
            }

            function tooShort(text, minLen) {
              return cleaned(text).length < minLen;
            }

            const problems = [];
            const neededLabels = new Set();

            // ---- BUG ENFORCEMENT ----
            if (isBug) {
              const what = extractSection('What happened?');
              const steps = extractSection('Steps to reproduce');
              const expected = extractSection('Expected behavior');
              const actual = extractSection('Actual behavior');

              // Optional sections from your template
              const logs = extractSection('Logs / screenshots');
              const env = extractSection('Environment details');

              if (looksLikePlaceholder(steps) || tooShort(steps, 25)) {
                neededLabels.add('needs-repro');
                problems.push('Steps to reproduce needs enough detail to follow (not N/A / too short).');
              }
              if (looksLikePlaceholder(what) || tooShort(what, 15)) {
                neededLabels.add('needs-info');
                problems.push('What happened? needs a clear description (not placeholder / too short).');
              }
              if (looksLikePlaceholder(expected) || tooShort(expected, 10)) {
                neededLabels.add('needs-info');
                problems.push('Expected behavior is missing or too vague.');
              }
              if (looksLikePlaceholder(actual) || tooShort(actual, 10)) {
                neededLabels.add('needs-info');
                problems.push('Actual behavior is missing or too vague.');
              }

              const hasLogs = !looksLikePlaceholder(logs) && !tooShort(logs, 10);
              const hasEnv = !looksLikePlaceholder(env) && !tooShort(env, 10);

              if (!hasLogs && !hasEnv) {
                neededLabels.add('needs-logs');
                problems.push('Please add logs/screenshots OR environment details so we can diagnose faster.');
              }
            }

            // ---- FEATURE ENFORCEMENT ----
            if (isFeature) {
              const problem = extractSection('Problem / Motivation');
              const proposal = extractSection('Proposed solution');
              const alternatives = extractSection('Alternatives considered'); // optional
              const scope = extractSection('Scope / Notes'); // optional

              if (looksLikePlaceholder(problem) || tooShort(problem, 25)) {
                neededLabels.add('needs-spec');
                problems.push('Problem / Motivation needs more detail (what are you trying to solve and why?).');
              }
              if (looksLikePlaceholder(proposal) || tooShort(proposal, 25)) {
                neededLabels.add('needs-spec');
                problems.push('Proposed solution needs enough detail to estimate and implement.');
              }

              // Soft nudge: if both optional fields are empty, encourage at least one
              const hasAlt = !looksLikePlaceholder(alternatives) && !tooShort(alternatives, 10);
              const hasScope = !looksLikePlaceholder(scope) && !tooShort(scope, 10);
              if (!hasAlt && !hasScope) {
                neededLabels.add('needs-spec');
                problems.push('Optional but helpful: add Scope/Notes or Alternatives considered (edge cases, UX notes, tradeoffs).');
              }
            }

            // Labels we manage (so we can remove them when issue becomes “healthy”)
            const gateLabels = ['needs-info','needs-repro','needs-logs','needs-spec'];

            async function ensureLabels(labelNames) {
              for (const name of labelNames) {
                try {
                  await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: [name] });
                } catch (e) {
                  if (e.status === 404) {
                    await github.rest.issues.createLabel({
                      owner, repo, name,
                      color: 'd73a4a',
                      description: 'Auto-applied by issue quality gate'
                    });
                    await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: [name] });
                  } else {
                    throw e;
                  }
                }
              }
            }

            async function removeLabel(name) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name });
              } catch (e) {
                if (e.status !== 404) core.warning(`Could not remove label ${name}: ${e.message}`);
              }
            }

            const botMarker = '<!-- watchforge-issue-quality-gate -->';

            async function alreadyCommented() {
              const comments = await github.rest.issues.listComments({ owner, repo, issue_number: issue.number, per_page: 100 });
              return comments.data.some(c => (c.body || '').includes(botMarker));
            }

            if (problems.length === 0) {
              // Issue looks good now -> remove our labels if present
              for (const l of gateLabels) await removeLabel(l);
              return;
            }

            // Apply needed labels
            await ensureLabels([...neededLabels]);

            // Post a single comment (avoid spam)
            if (!(await alreadyCommented())) {
              const checklist = problems.map(p => `- [ ] ${p}`).join('\n');
              const msg =
                `${botMarker}\n` +
                `Thanks — a couple items need clarification before we can move this forward.\n\n` +
                `${checklist}\n\n` +
                `When you update the issue, these labels will clear automatically.\n`;
              await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: msg });
            }
