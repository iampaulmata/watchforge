name: Issue Quality Gate

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  issues: write

jobs:
  bug_report_quality_gate:
    name: Bug report quality check
    runs-on: ubuntu-latest

    steps:
      - name: Validate bug report content
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue = context.payload.issue;

            const labels = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name));
            if (!labels.includes('bug')) return;

            const body = (issue.body || '').trim();

            // Issue Forms render headings like "### Steps to reproduce"
            function extractSection(heading) {
              const re = new RegExp(`^###\\s+${heading}\\s*$([\\s\\S]*?)(?=\\n###\\s+|$)`, 'mi');
              const match = body.match(re);
              return match ? (match[1] || '').trim() : '';
            }

            const placeholderPhrases = new Set([
              'n/a','na','none','nothing','no','tbd','todo','unknown','-','--','idk',"i don't know",'i dont know'
            ]);

            function normalize(text) {
              return (text || '')
                .replace(/<!--[\s\S]*?-->/g, '')     // strip comments
                .replace(/\r/g, '')
                .trim();
            }

            function looksLikePlaceholder(text) {
              const cleaned = normalize(text)
                .replace(/\s+/g, ' ')
                .toLowerCase();
              if (!cleaned) return true;
              if (placeholderPhrases.has(cleaned)) return true;
              // Common "filler" patterns
              if (cleaned === 'same as above') return true;
              return false;
            }

            function tooShort(text, minLen) {
              const cleaned = normalize(text).replace(/\s+/g, ' ');
              return cleaned.length < minLen;
            }

            // Extract required-ish sections
            const what = extractSection('What happened?');
            const steps = extractSection('Steps to reproduce');
            const expected = extractSection('Expected behavior');
            const actual = extractSection('Actual behavior');

            // Optional sections from your template
            const logs = extractSection('Logs / screenshots');
            const env = extractSection('Environment details');

            const problems = [];

            // Stronger checks than "required"
            if (looksLikePlaceholder(steps) || tooShort(steps, 25)) {
              problems.push({ label: 'needs-repro', text: 'Steps to reproduce needs enough detail to follow (not N/A / too short).' });
            }
            if (looksLikePlaceholder(what) || tooShort(what, 15)) {
              problems.push({ label: 'needs-info', text: 'What happened? needs a clear description (not placeholder / too short).' });
            }
            if (looksLikePlaceholder(expected) || tooShort(expected, 10)) {
              problems.push({ label: 'needs-info', text: 'Expected behavior is missing or too vague.' });
            }
            if (looksLikePlaceholder(actual) || tooShort(actual, 10)) {
              problems.push({ label: 'needs-info', text: 'Actual behavior is missing or too vague.' });
            }

            // “At least one useful artifact” rule (soft requirement, but helps a ton)
            const hasLogs = !looksLikePlaceholder(logs) && !tooShort(logs, 10);
            const hasEnv = !looksLikePlaceholder(env) && !tooShort(env, 10);

            if (!hasLogs && !hasEnv) {
              problems.push({ label: 'needs-logs', text: 'Please add logs/screenshots OR environment details so we can diagnose faster.' });
            }

            // Helper to ensure labels exist and apply them
            async function ensureLabels(labelNames) {
              for (const name of labelNames) {
                try {
                  await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: [name] });
                } catch (e) {
                  if (e.status === 404) {
                    await github.rest.issues.createLabel({
                      owner, repo, name,
                      color: 'd73a4a',
                      description: 'Auto-applied by issue quality gate'
                    });
                    await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: [name] });
                  } else {
                    throw e;
                  }
                }
              }
            }

            // Remove quality-gate labels when issue is healthy
            async function removeLabel(name) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name });
              } catch (e) {
                if (e.status !== 404) core.warning(`Could not remove label ${name}: ${e.message}`);
              }
            }

            const gateLabels = ['needs-info','needs-repro','needs-logs'];
            const botMarker = '<!-- watchforge-issue-quality-gate -->';

            async function alreadyCommented() {
              const comments = await github.rest.issues.listComments({ owner, repo, issue_number: issue.number, per_page: 100 });
              return comments.data.some(c => (c.body || '').includes(botMarker));
            }

            if (problems.length === 0) {
              // Clean slate: remove labels if present
              for (const l of gateLabels) await removeLabel(l);
              return;
            }

            const needed = [...new Set(problems.map(p => p.label))];
            await ensureLabels(needed);

            if (!(await alreadyCommented())) {
              const checklist = problems.map(p => `- [ ] ${p.text}`).join('\n');
              const msg =
                `${botMarker}\n` +
                `Thanks for the report — a couple items need clarification before we can reliably reproduce or diagnose this.\n\n` +
                `${checklist}\n\n` +
                `When you update the issue, these labels will clear automatically.\n`;
              await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: msg });
            }
