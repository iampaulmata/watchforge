name: Issue Quality Gate

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  issues: write

jobs:
  bug_report_quality_gate:
    name: Bug report completeness check
    runs-on: ubuntu-latest

    steps:
      - name: Validate bug report content
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue = context.payload.issue;

            // Only enforce for bug reports (your bug template applies "bug" label)
            const labels = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name));
            if (!labels.includes('bug')) {
              core.info('Not a bug issue; skipping.');
              return;
            }

            const body = (issue.body || '').trim();

            // Helper: find content under a heading generated by Issue Forms.
            // Issue Forms commonly render headings like "### Steps to reproduce"
            function extractSection(heading) {
              const re = new RegExp(`^###\\s+${heading}\\s*$([\\s\\S]*?)(?=\\n###\\s+|$)`, 'mi');
              const match = body.match(re);
              if (!match) return '';
              return (match[1] || '').trim();
            }

            // Helper: determine if a section is effectively empty
            function isEmpty(sectionText) {
              if (!sectionText) return true;
              const cleaned = sectionText
                .replace(/<!--[\s\S]*?-->/g, '')     // strip HTML comments
                .replace(/`{3}[\s\S]*?`{3}/g, '')    // strip fenced code blocks (optional)
                .replace(/\s+/g, ' ')
                .trim();

              // Common "empty" placeholders people leave behind
              const empties = [
                'n/a', 'na', 'none', 'nothing', 'no', 'tbd', 'todo',
                'i don’t know', "i don't know", 'unknown', '-'
              ];
              if (!cleaned) return true;
              if (empties.includes(cleaned.toLowerCase())) return true;

              // If it's extremely short, treat as empty to force useful detail
              if (cleaned.length < 8) return true;

              return false;
            }

            const requiredSections = [
              { key: 'What happened?', heading: 'What happened?' },
              { key: 'Steps to reproduce', heading: 'Steps to reproduce' },
              { key: 'Expected behavior', heading: 'Expected behavior' },
              { key: 'Actual behavior', heading: 'Actual behavior' },
            ];

            const missing = [];

            for (const s of requiredSections) {
              const content = extractSection(s.heading);
              if (isEmpty(content)) missing.push(s.key);
            }

            // If missing content, enforce: label + comment (+ optional close)
            const needsInfoLabel = 'needs-info';
            const shouldClose = false; // <-- CHANGE TO false if you only want labels/comments

            async function ensureLabel(labelName) {
              // Add label if it exists; if it doesn't, attempt to create it.
              try {
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: issue.number, labels: [labelName]
                });
              } catch (e) {
                // If label doesn't exist, create it and retry
                if (e.status === 404) {
                  core.info(`Label "${labelName}" not found. Creating it...`);
                  await github.rest.issues.createLabel({
                    owner, repo,
                    name: labelName,
                    color: 'd73a4a',
                    description: 'Missing required info to reproduce/resolve'
                  });
                  await github.rest.issues.addLabels({
                    owner, repo, issue_number: issue.number, labels: [labelName]
                  });
                } else {
                  throw e;
                }
              }
            }

            // Avoid spamming duplicate comments: check if we already posted our bot message
            const botMarker = '<!-- watchforge-bug-quality-gate -->';

            async function alreadyCommented() {
              const comments = await github.rest.issues.listComments({
                owner, repo, issue_number: issue.number, per_page: 100
              });
              return comments.data.some(c => (c.body || '').includes(botMarker));
            }

            if (missing.length === 0) {
              core.info('Bug report looks complete. Removing needs-info if present.');
              // Remove needs-info label if it exists
              try {
                await github.rest.issues.removeLabel({
                  owner, repo, issue_number: issue.number, name: needsInfoLabel
                });
              } catch (e) {
                // ignore if label not present
                if (e.status !== 404) core.warning(`Could not remove label: ${e.message}`);
              }
              // If it was previously closed by the bot, you could optionally reopen here.
              return;
            }

            core.info(`Missing sections: ${missing.join(', ')}`);

            await ensureLabel(needsInfoLabel);

            if (!(await alreadyCommented())) {
              const checklist = missing.map(m => `- [ ] ${m}`).join('\n');

              const message =
                `${botMarker}\n` +
                `Thanks for the bug report — I need a bit more detail before we can reproduce and fix this.\n\n` +
                `Please update the issue with the following:\n\n` +
                `${checklist}\n\n` +
                `Once you add the missing info, this will automatically move forward.\n`;

              await github.rest.issues.createComment({
                owner, repo, issue_number: issue.number, body: message
              });
            }

            if (shouldClose && issue.state === 'open') {
              await github.rest.issues.update({
                owner, repo, issue_number: issue.number, state: 'closed'
              });
            }
